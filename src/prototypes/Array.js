Object.defineProperty(Array.prototype, "trim", {
    value: function (f) {
        return this.filter(v => v);
    }
});

Object.defineProperty(Array.prototype, "groupBy", {
    value: function (k, f) {
        return this.reduce((g, v) => {g[k(v)] ? g[k(v)].push(f ? f(v) : v) : g[k(v)] = [f ? f(v) : v]; return g;}, {});
    }
});

Object.defineProperty(Array.prototype, "toDictionary", {
    value: function (k, f) {
        return this.reduce((d, v) => {d[k(v)] = f ? f(v) : v; return d;}, {});
    }
});

Object.defineProperty(Array.prototype, "mapReduce", {
    value: function (f) {
        return this.reduce((a, v) => {a.push(...f(v)); return a;}, []);
    }
});

Object.defineProperty(Array.prototype, "orderBy", {
    value: function (f) {
        return [...this].sort(function (a, b) {
            return (f(a) > f(b)) ? 1 : (f(a) < f(b)) ? -1 : 0;
        });
    }
});

Object.defineProperty(Array.prototype, "orderByDesc", {
    value: function (f) {
        return [...this].sort(function (a, b) {
            return (f(a) < f(b)) ? 1 : (f(a) > f(b)) ? -1 : 0;
        });
    }
});

Object.defineProperty(Array.prototype, "sum", {
    value: function (f) {
        return this.reduce((s, v) => s += f ? f(v) : v, 0);
    }
});

Object.defineProperty(Array.prototype, "distinct", {
    value: function () {
        return [...new Set(this)];
    }
});

// this one was generated by chat gpt
/*
Array.prototype.groupBy = function(...args) {
  const keySelectors = args.slice(0, -1);
  const transformFn = args[args.length - 1];

  function groupByRecursive(arr, selectors, transform) {
    if (selectors.length === 0) {
      return arr;
    }

    const keySelector = selectors[0];
    const grouped = arr.reduce((groups, item) => {
      const key = keySelector(item);
      if (!groups[key]) {
        groups[key] = [];
      }
      const transformedItem = transform(item);
      groups[key].push(transformedItem);
      return groups;
    }, {});

    for (const key in grouped) {
      grouped[key] = groupByRecursive(grouped[key], selectors.slice(1), transform);
    }

    return grouped;
  }

  return groupByRecursive(this, keySelectors, transformFn);
};

*/