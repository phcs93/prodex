Object.defineProperty(Array.prototype, "mapReduce", {
    value: function (f) {
        return this.reduce((acc, crr) => {acc.push(...f(crr)); return acc;}, []);
    }
});

Object.defineProperty(Array.prototype, "orderBy", {
    value: function (f) {
        return [...this].sort(function (a, b) {
            return (f(a) > f(b)) ? 1 : (f(a) < f(b)) ? -1 : 0;
        });
    }
});

Object.defineProperty(Array.prototype, "orderByDesc", {
    value: function (f) {
        return [...this].sort(function (a, b) {
            return (f(a) < f(b)) ? 1 : (f(a) > f(b)) ? -1 : 0;
        });
    }
});

Object.defineProperty(Array.prototype, "groupBy", {
    value: function (f) {
        return this.reduce((g, v) => {g[f(v)] ? g[f(v)].push(v) : g[f(v)] = [v]; return g;}, {});
    }
});

Object.defineProperty(Object.prototype, "thenBy", {
    value: function(f) {
        for (const k of Object.keys(this)) {
            this[k] = this[k].groupBy(f);
        }
        return this;
    }
});

Object.defineProperty(Array.prototype, "mapGroupBy", {
    value: function (f, m) {
        return this.reduce((g, v) => {g[f(v)] ? g[f(v)].push(m(v)) : g[f(v)] = [m(v)]; return g;}, {});
    }
});

Object.defineProperty(Object.prototype, "mapThenBy", {
    value: function(f, m) {
        for (const k of Object.keys(this)) {
            this[k] = this[k].mapGroupBy(f, m);
        }
        return this;
    }
});

Object.defineProperty(Array.prototype, "toDictionary", {
    value: function (f) {
        return this.reduce((acc, crr) => {acc[f(crr)] = crr; return acc;}, {});
    }
});

Object.defineProperty(Array.prototype, "mapToDictionary", {
    value: function (f, m) {
        return this.reduce((acc, crr) => {acc[f(crr)] = m(crr); return acc;}, {});
    }
});

Object.defineProperty(Array.prototype, "sum", {
    value: function (f) {
        return this.reduce((sum, v) => sum += f(v), 0);
    }
});

Object.defineProperty(Array.prototype, "distinct", {
    value: function () {
        return [...new Set(this)];
    }
});

// this one was generated by chat gpt
/*
Array.prototype.groupBy = function(...args) {
  const keySelectors = args.slice(0, -1);
  const transformFn = args[args.length - 1];

  function groupByRecursive(arr, selectors, transform) {
    if (selectors.length === 0) {
      return arr;
    }

    const keySelector = selectors[0];
    const grouped = arr.reduce((groups, item) => {
      const key = keySelector(item);
      if (!groups[key]) {
        groups[key] = [];
      }
      const transformedItem = transform(item);
      groups[key].push(transformedItem);
      return groups;
    }, {});

    for (const key in grouped) {
      grouped[key] = groupByRecursive(grouped[key], selectors.slice(1), transform);
    }

    return grouped;
  }

  return groupByRecursive(this, keySelectors, transformFn);
};

*/